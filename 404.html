<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Non Trouv√©e - Troupe Saint Elme</title>
    <link rel="stylesheet" href="https://javabatchcss.github.io/Troupe-Saint-Elme/style.css">
    <link rel="icon" href="https://javabatchcss.github.io/Troupe-Saint-Elme/images/embleme troupe.png">
    <script src="https://javabatchcss.github.io/Troupe-Saint-Elme/mobile-menu.js"></script>
    <style>
        /* Styles sp√©cifiques √† la page 404 */
        .not-found-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            margin: 40px auto;
            padding: 30px;
            text-align: center;
        }
        
        .not-found-container h1 {
            color: #3498db;
            text-align: center;
            margin-bottom: 25px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 15px;
            font-size: 2.5em;
        }

        h2 {
            color: #3498db;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #3498db;
            font-size: 1.5em;
        }
        
        .compass-icon {
            display: block;
            width: 120px;
            height: 120px;
            background-color: #ebf5fb;
            border-radius: 50%;
            margin: 30px auto;
            position: relative;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .compass-icon:before {
            content: "";
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            border-radius: 50%;
            border: 3px solid #3498db;
            box-sizing: border-box;
        }
        
        .compass-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 3px;
            background-color: #3498db;
            transform: translate(-50%, -50%) rotate(45deg);
            transform-origin: center;
            animation: compass-spin 3s ease-in-out infinite alternate;
        }
        
        .compass-needle:after {
            content: "";
            position: absolute;
            top: -4px;
            right: -4px;
            width: 10px;
            height: 10px;
            background-color: #e74c3c;
            border-radius: 50%;
        }
        
        @keyframes compass-spin {
            0% { transform: translate(-50%, -50%) rotate(45deg); }
            100% { transform: translate(-50%, -50%) rotate(225deg); }
        }
        
        .error-code {
            font-size: 5em;
            font-weight: bold;
            color: #3498db;
            margin: 0;
            line-height: 1.2;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .error-message {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        /* Suggestions de pages */
        .search-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        
        .search-input {
            display: flex;
            margin-bottom: 20px;
        }
        
        .search-input input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px 0 0 8px;
            font-size: 1rem;
        }
        
        .search-input button {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            padding: 0 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .search-input button:hover {
            background-color: #2980b9;
        }
        
        .suggestions-title {
            font-size: 1.2em;
            color: #3498db;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .suggestions-list {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }
        
        .suggestion-item {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }
        
        .suggestion-item:hover {
            background-color: #ebf5fb;
            border-left-color: #3498db;
        }
        
        .suggestion-item a {
            color: #2c3e50;
            text-decoration: none;
            display: block;
            font-weight: 500;
        }
        
        .suggestion-item .match-score {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .suggestion-item .page-description {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .highlight {
            background-color: #fffacd;
            padding: 0 3px;
            border-radius: 3px;
        }
        
        .no-suggestions {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            color: #7f8c8d;
            text-align: center;
            font-style: italic;
        }
        
        /* En-t√™te adapt√© pour la page 404 */
        header {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 30px;
        }
        
        header .logo-title {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        header img {
            height: 75px;
            margin-right: 20px;
        }
        
        header h1 {
            margin: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        
        /* Navigation principale */
        .navigation-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }
        
        .nav-option {
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px 20px;
            color: #2c3e50;
            text-decoration: none;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex: 0 0 calc(33.333% - 20px);
            justify-content: center;
            min-width: 150px;
        }
        
        .nav-option:hover {
            background-color: #ebf5fb;
            border-color: #3498db;
            color: #3498db;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.2);
        }
        
        /* Loader pour le chargement des suggestions */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Message de chemin actuel */
        .current-path {
            margin-top: 20px;
            padding: 8px 15px;
            background-color: #f1f1f1;
            border-radius: 4px;
            display: inline-block;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .error-code {
                font-size: 4em;
            }
            
            .error-message {
                font-size: 1.2em;
            }
            
            .nav-option {
                flex: 0 0 calc(50% - 15px);
            }
            
            .search-input {
                flex-direction: column;
            }
            
            .search-input input {
                border-radius: 8px;
                margin-bottom: 10px;
            }
            
            .search-input button {
                border-radius: 8px;
                padding: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .not-found-container {
                margin: 20px;
                padding: 20px;
            }
            
            .nav-option {
                flex: 0 0 100%;
            }
            
            .compass-icon {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo-title">
            <img style="right:20px" src="images/embleme troupe.png">
            <img style="left:20px" src="images/logo f√©d√©ration.png">
            <h1>Troupe Saint Elme</h1>
        </div>
        <nav>
            <ul>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/index.html" class="active">Accueil</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/annee_2023.html">2023</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/annee_2024.html">2024</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/annee_2025.html">2025</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/about-us.html">√Ä Propos</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/contact-us.html"">Contact</a></li>
            <li><a href="https://javabatchcss.github.io/Troupe-Saint-Elme/documentation.html">Documentation</a></li>
            <li><a href="https://www.fsggb.fr/">Site de la F√©d√©ration</a></li>
        </ul>
        </nav>
    </header>
    
    <main>
        <div class="not-found-container">
            <p class="error-code">404</p>
            <h1>Page Non Trouv√©e</h1>
            
            <div class="compass-icon">
                <div class="compass-needle"></div>
            </div>
            
            <p class="error-message">Oups ! Il semble que vous vous soyez √©gar√© dans la for√™t...</p>
            
            <p>La page que vous recherchez n'existe pas ou a √©t√© d√©plac√©e.</p>
            
            <div class="current-path" id="current-path">Chemin recherch√©: </div>
            
            <div class="search-container">
                <div class="suggestions-title">Peut-√™tre cherchiez-vous...</div>
                <div class="search-input" style="gap:8px;">
                    <input type="text" id="search-term" placeholder="Tapez votre recherche...">
                    <button id="search-button">Rechercher</button>
                </div>
                <div class="loader" id="search-loader"></div>
                <div id="suggestions-container">
                    <ul class="suggestions-list" id="suggestions-list">
                        <!-- Les suggestions seront g√©n√©r√©es dynamiquement ici -->
                    </ul>
                </div>
                <!-- Arborescence des fichiers du d√©p√¥t -->
                <div id="github-files-list" style="margin-top:20px; text-align:left;">
                    <strong><h2>Fichiers du d√©p√¥t :</h2></strong>
                    <div id="github-files-loader" style="margin:10px 0;">Chargement des fichiers...</div>
                    <div id="github-files-tree"></div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        <p>&copy; Troupe Saint Elme</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        // Liste des pages du site (√† g√©n√©rer/mettre √† jour automatiquement)
        if (typeof sitePages === "undefined") {
            var sitePages = [];
        }

        // Fonction pour r√©cup√©rer les param√®tres d'URL
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // Fonction pour calculer la similarit√© entre deux cha√Ænes (algorithme de Levenshtein)
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            const matrix = [];
            
            // Incr√©mente le long de la premi√®re colonne de chaque ligne
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            // Incr√©mente chaque colonne dans la premi√®re ligne
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            // Remplit le reste de la matrice
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i-1) === a.charAt(j-1)) {
                        matrix[i][j] = matrix[i-1][j-1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i-1][j-1] + 1, // substitution
                            Math.min(
                                matrix[i][j-1] + 1, // insertion
                                matrix[i-1][j] + 1  // suppression
                            )
                        );
                    }
                }
            }
            
            return matrix[b.length][a.length];
        }

        // Fonction pour calculer la similarit√© en pourcentage
        function similarityPercentage(a, b) {
            const maxLength = Math.max(a.length, b.length);
            if (maxLength === 0) return 100; // Si les deux cha√Ænes sont vides
            
            const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
            return Math.round((1 - distance / maxLength) * 100);
        }

        // Fonction pour rechercher des pages similaires
        function findSimilarPages(searchTerm) {
            if (!searchTerm) return [];
            
            // Pr√©parer le terme de recherche (enlever l'extension .html si pr√©sente)
            let cleanSearchTerm = searchTerm.toLowerCase();
            if (cleanSearchTerm.endsWith('.html')) {
                cleanSearchTerm = cleanSearchTerm.slice(0, -5);
            }
            
            // Rechercher parmi toutes les pages
            const results = sitePages.map(page => {
                // Pr√©parer le chemin de la page pour la comparaison
                let pagePath = page.path.toLowerCase();
                if (pagePath.endsWith('.html')) {
                    pagePath = pagePath.slice(0, -5);
                }
                
                // Calcul de similarit√©
                const pathSimilarity = similarityPercentage(cleanSearchTerm, pagePath);
                const titleSimilarity = similarityPercentage(cleanSearchTerm, page.title.toLowerCase());
                const descSimilarity = similarityPercentage(cleanSearchTerm, page.description.toLowerCase());
                
                // Prendre la meilleure correspondance
                const similarity = Math.max(pathSimilarity, titleSimilarity, descSimilarity);
                
                return {
                    ...page,
                    similarity
                };
            });
            
            // Trier par similarit√© et filtrer uniquement les r√©sultats pertinents (>= 30%)
            return results
                .filter(result => result.similarity >= 30)
                .sort((a, b) => b.similarity - a.similarity);
        }

        // Fonction pour mettre en √©vidence les termes de recherche dans le texte
        function highlightTerm(text, term) {
            if (!term) return text;
            
            // √âchappement des caract√®res sp√©ciaux pour la regex
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedTerm})`, 'gi');
            
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        // Fonction pour afficher les suggestions
        function displaySuggestions(suggestions, searchTerm) {
            const suggestionsList = document.getElementById('suggestions-list');
            suggestionsList.innerHTML = '';
            
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '<div class="no-suggestions">Aucune suggestion trouv√©e.</div>';
                return;
            }
            
            suggestions.forEach(suggestion => {
                const li = document.createElement('li');
                li.className = 'suggestion-item';
                
                const title = highlightTerm(suggestion.title, searchTerm);
                const path = highlightTerm(suggestion.path, searchTerm);
                const description = highlightTerm(suggestion.description, searchTerm);
                
                li.innerHTML = `
                    <a href="${suggestion.path}">
                        <strong>${title}</strong>
                        <div class="page-description">${description}</div>
                        <div class="match-score">
                            <span>Chemin: ${path}</span>
                            <span style="float: right;">Correspondance: ${suggestion.similarity}%</span>
                        </div>
                    </a>
                `;
                
                suggestionsList.appendChild(li);
            });
        }

        // Fonction pour effectuer la recherche
        function performSearch() {
            const searchTerm = document.getElementById('search-term').value.trim();
            const loader = document.getElementById('search-loader');
            
            if (!searchTerm) return;
            
            // Afficher le loader
            loader.style.display = 'block';
            
            // Simuler un d√©lai de chargement pour l'effet (optionnel)
            setTimeout(() => {
                const suggestions = findSimilarPages(searchTerm);
                displaySuggestions(suggestions, searchTerm);
                loader.style.display = 'none';
            }, 500);
        }

        // Gestionnaire d'√©v√©nements pour le bouton de recherche
        document.getElementById('search-button').addEventListener('click', performSearch);
        
        // Gestionnaire d'√©v√©nements pour la touche Entr√©e dans le champ de recherche
        document.getElementById('search-term').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                performSearch();
            }
        });

        // --- D√©chiffrement des infos GitHub s√©curis√©es ---
        function decrypt(encryptedText) {
            try {
                return CryptoJS.AES.decrypt(encryptedText, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null;
            }
        }
        function getSecureValue(key) {
            if (!encryptedData[key]) return null;
            return decrypt(encryptedData[key]);
        }

        // --- R√©cup√©ration efficace de tous les fichiers du d√©p√¥t via l'API GitHub (v3 REST) ---
        // Correction : v√©rification explicite des valeurs d√©chiffr√©es et logs pour debug
        async function fetchAllGithubFilesV3() {
            let owner = getSecureValue('githubOwner') || "javabatchcss";
            let repo = getSecureValue('githubRepo') || "Troupe-Saint-Elme";
            let branch = getSecureValue('githubBranch') || "main";
            // Correction : forcer en minuscules pour GitHub
            owner = owner.trim();
            repo = repo.trim();
            branch = branch.trim();
            // Essaye d'abord la branche indiqu√©e, puis l'autre (main/master)
            let triedBranches = [branch];
            if (branch === "main") triedBranches.push("master");
            else if (branch === "master") triedBranches.push("main");
            else triedBranches.push("main", "master");
            let branchData = null, sha = null, usedBranch = null;
            for (const tryBranch of triedBranches) {
                const branchUrl = `https://api.github.com/repos/${owner}/${repo}/branches/${tryBranch}`;
                try {
                    const branchResp = await fetch(branchUrl);
                    if (branchResp.ok) {
                        branchData = await branchResp.json();
                        usedBranch = tryBranch;
                        break;
                    }
                } catch (e) {
                    // ignore
                }
            }
            if (!branchData) {
                console.error("Impossible d'acc√©der √† la branche main/master du d√©p√¥t GitHub.");
                return [];
            }
            if (branchData.commit && branchData.commit.commit && branchData.commit.commit.tree && branchData.commit.commit.tree.sha) {
                sha = branchData.commit.commit.tree.sha;
            } else if (branchData.commit && branchData.commit.tree && branchData.commit.tree.sha) {
                sha = branchData.commit.tree.sha;
            } else if (branchData.commit && branchData.commit.sha) {
                // Fallback: on va chercher le commit pour avoir le tree
                const commitUrl = `https://api.github.com/repos/${owner}/${repo}/git/commits/${branchData.commit.sha}`;
                try {
                    const commitResp = await fetch(commitUrl);
                    if (commitResp.ok) {
                        const commitData = await commitResp.json();
                        if (commitData.tree && commitData.tree.sha) {
                            sha = commitData.tree.sha;
                        }
                    }
                } catch (e) {}
            }
            if (!sha) {
                console.error("Impossible de d√©terminer le SHA du tree du d√©p√¥t.");
                return [];
            }
            // On r√©cup√®re l'arbre complet
            const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${sha}?recursive=1`;
            try {
                const treeResp = await fetch(treeUrl);
                if (!treeResp.ok) {
                    console.error("Erreur HTTP tree:", treeResp.status, treeResp.statusText, treeUrl);
                    return [];
                }
                const treeData = await treeResp.json();
                if (!treeData.tree) {
                    console.error("R√©ponse API tree sans champ 'tree':", treeData);
                    return [];
                }
                return treeData.tree;
            } catch (e) {
                console.error("Erreur r√©seau lors de la requ√™te tree:", e);
                return [];
            }
        }

        function getRawUrl(path) {
            return `https://javabatchcss.github.io/Troupe-Saint-Elme/${path}`;
        }

        // Retourne une ic√¥ne unicode selon l'extension du fichier
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch (ext) {
                case "html":
                case "htm":
                    return "üåê";
                case "css":
                    return "üé®";
                case "js":
                case "mjs":
                case "cjs":
                    return "üìú";
                case "json":
                    return "üóÑÔ∏è";
                case "jpg":
                case "jpeg":
                case "png":
                case "gif":
                case "bmp":
                case "svg":
                case "webp":
                    return "üñºÔ∏è";
                case "pdf":
                    return "üìÑ";
                case "doc":
                case "docx":
                    return "üìù";
                case "xls":
                case "xlsx":
                    return "üìä";
                case "ppt":
                case "pptx":
                    return "üìà";
                case "zip":
                case "rar":
                case "7z":
                case "tar":
                case "gz":
                    return "üóúÔ∏è";
                case "mp3":
                case "wav":
                case "ogg":
                    return "üéµ";
                case "mp4":
                case "avi":
                case "mov":
                case "webm":
                case "mkv":
                    return "üé¨";
                case "md":
                    return "üìò";
                case "txt":
                    return "üìÑ";
                default:
                    return "üìÅ" === filename ? "üìÅ" : "üìÑ";
            }
        }

        // Construit une arborescence √† partir de la liste plate des fichiers (enregistre la taille)
        function buildTree(items) {
            const root = {};
            items.forEach(item => {
                const parts = item.path.split('/');
                let current = root;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        if (item.type === "blob") {
                            current[part] = { __file: true, path: item.path, size: item.size };
                        } else if (item.type === "tree") {
                            current[part] = current[part] || {};
                        }
                    } else {
                        current[part] = current[part] || {};
                        current = current[part];
                    }
                }
            });
            return root;
        }

        // Modifie renderTreeCollapsible pour utiliser l'ic√¥ne selon le type de fichier
        function renderTreeCollapsible(node, parentPath = "", level = 0, folderIdPrefix = "root") {
            let html = "<ul style='list-style:none; margin:0; padding-left:" + (level * 24) + "px;'>";
            const files = [];
            const folders = [];
            for (const key of Object.keys(node)) {
                const value = node[key];
                if (value && value.__file) files.push(key);
                else folders.push(key);
            }
            files.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));
            folders.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));

            // Affiche d'abord les fichiers
            for (const key of files) {
                const value = node[key];
                html += `<li style="position:relative; padding-left:8px;">
                    <span>${getFileIcon(key)}</span> 
                    <a href="${getRawUrl(value.path)}" target="_blank" style="color:#3498db;text-decoration:none;" 
                        onmouseover="this.style.textDecoration='underline'" 
                        onmouseout="this.style.textDecoration='none'">${key}</a>
                    <span style="position:absolute; right:0; color:#888; font-size:0.9em;">${formatSize(value.size)}</span>
                </li>`;
            }
            // Puis les dossiers
            for (const key of folders) {
                const value = node[key];
                const folderId = folderIdPrefix + "-" + btoa(parentPath + key).replace(/=/g, "");
                html += `<li style="position:relative;">
                    <span style="font-weight:bold; color:#2c3e50; cursor:pointer;" onclick="toggleFolder('${folderId}')">
                        <span id="${folderId}-icon">‚ñ∂Ô∏è</span> üìÅ ${key}/
                    </span>
                    <span style="position:absolute; right:0; color:#888; font-size:0.9em;"></span>
                    <div id="${folderId}" style="display:none;"></div>
                </li>`;
            }
            html += "</ul>";
            return html;
        }

        // Modifie renderTreeSearch pour utiliser l'ic√¥ne selon le type de fichier
        function renderTreeSearch(node, parentPath = "", filter = "", level = 0) {
            let html = "<ul style='list-style:none; margin:0; padding-left:" + (level * 24) + "px;'>";
            const files = [];
            const folders = [];
            for (const key of Object.keys(node)) {
                const value = node[key];
                if (value && value.__file) files.push(key);
                else folders.push(key);
            }
            files.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));
            folders.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));

            // Fichiers filtr√©s
            for (const key of files) {
                const value = node[key];
                if (!filter || key.toLowerCase().includes(filter.toLowerCase())) {
                    html += `<li style="position:relative; padding-left:8px;">
                        <span>${getFileIcon(key)}</span> 
                        <a href="${getRawUrl(value.path)}" target="_blank" style="color:#3498db;text-decoration:none;" 
                            onmouseover="this.style.textDecoration='underline'" 
                            onmouseout="this.style.textDecoration='none'">${key}</a>
                        <span style="position:absolute; right:0; color:#888; font-size:0.9em;">${formatSize(value.size)}</span>
                    </li>`;
                }
            }
            // Dossiers filtr√©s r√©cursivement
            for (const key of folders) {
                const value = node[key];
                const subHtml = renderTreeSearch(value, parentPath + key + "/", filter, level + 1);
                if (subHtml.includes("<li")) {
                    html += `<li style="position:relative;">
                        <span style="font-weight:bold; color:#2c3e50;">üìÅ ${key}/</span>
                        <span style="position:absolute; right:0; color:#888; font-size:0.9em;"></span>
                        ${subHtml}
                    </li>`;
                }
            }
            html += "</ul>";
            return html;
        }

        // G√©n√®re le HTML de l'arborescence avec dossiers repliables (clic pour ouvrir/fermer)
        // Les fichiers sont list√©s avant les dossiers, le tout tri√© alphab√©tiquement
        function renderTreeCollapsible(node, parentPath = "", level = 0, folderIdPrefix = "root") {
            let html = "<ul style='list-style:none; margin:0; padding-left:" + (level * 24) + "px;'>";
            const files = [];
            const folders = [];
            for (const key of Object.keys(node)) {
                const value = node[key];
                if (value && value.__file) files.push(key);
                else folders.push(key);
            }
            files.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));
            folders.sort((a, b) => a.localeCompare(b, 'fr', {sensitivity: 'base'}));

            // Affiche d'abord les fichiers
            for (const key of files) {
                const value = node[key];
                html += `<li style="position:relative; padding-left:8px;">
                    <span>${getFileIcon(key)}</span> 
                    <a href="${getRawUrl(value.path)}" target="_blank" style="color:#3498db;text-decoration:none;" 
                        onmouseover="this.style.textDecoration='underline'" 
                        onmouseout="this.style.textDecoration='none'">${key}</a>
                    <span style="position:absolute; right:0; color:#888; font-size:0.9em;">${formatSize(value.size)}</span>
                </li>`;
            }
            // Puis les dossiers
            for (const key of folders) {
                const value = node[key];
                const folderId = folderIdPrefix + "-" + btoa(parentPath + key).replace(/=/g, "");
                html += `<li style="position:relative;">
                    <span style="font-weight:bold; color:#2c3e50; cursor:pointer;" onclick="toggleFolder('${folderId}')">
                        <span id="${folderId}-icon">‚ñ∂Ô∏è</span> üìÅ ${key}/
                    </span>
                    <span style="position:absolute; right:0; color:#888; font-size:0.9em;"></span>
                    <div id="${folderId}" style="display:none;"></div>
                </li>`;
            }
            html += "</ul>";
            return html;
        }

        // Fonction pour ouvrir/fermer un dossier au clic
        window.toggleFolder = function(folderId) {
            const folderDiv = document.getElementById(folderId);
            const icon = document.getElementById(folderId + "-icon");
            if (!folderDiv) return;
            if (folderDiv.innerHTML === "") {
                // Ouvre le dossier (affiche son contenu)
                const path = atob(folderId.split("-").slice(1).join("-"));
                const node = getNodeByPath(globalGithubTree, path.split('/').filter(Boolean));
                folderDiv.innerHTML = renderTreeCollapsible(node, path + (path ? "/" : ""), (path ? path.split('/').length : 0) + 1, folderId);
                folderDiv.style.display = "block";
                if (icon) icon.textContent = "‚ñº";
            } else if (folderDiv.style.display === "none") {
                folderDiv.style.display = "block";
                if (icon) icon.textContent = "‚ñº";
            } else {
                folderDiv.style.display = "none";
                if (icon) icon.textContent = "‚ñ∂Ô∏è";
            }
        };

        // R√©cup√®re le noeud d'arbre correspondant √† un chemin
        function getNodeByPath(tree, parts) {
            let node = tree;
            for (const part of parts) {
                if (node && node[part]) node = node[part];
                else return {};
            }
            return node;
        }

        // Format la taille en octets en Ko/Mo lisible
        function formatSize(size) {
            if (!size && size !== 0) return "";
            if (size < 1024) return size + " o";
            if (size < 1024 * 1024) return (size / 1024).toFixed(1) + " Ko";
            return (size / (1024 * 1024)).toFixed(2) + " Mo";
        }

        let globalGithubTree = null;

        async function displayGithubFilesTree(filter = "") {
            const loader = document.getElementById('github-files-loader');
            const treeDiv = document.getElementById('github-files-tree');
            treeDiv.innerHTML = '';
            loader.style.display = 'block';

            if (!globalGithubTree) {
                const items = await fetchAllGithubFilesV3();
                if (!items.length) {
                    loader.style.display = 'none';
                    treeDiv.innerHTML = '<span style="color:#e74c3c;">Impossible de charger la liste des fichiers.</span>';
                    return;
                }
                const filtered = items.filter(item => item.type === "blob" || item.type === "tree");
                globalGithubTree = buildTree(filtered);
            }
            loader.style.display = 'none';
            if (filter) {
                // Recherche : tout d√©plier et filtrer, fichiers avant dossiers
                treeDiv.innerHTML = renderTreeSearch(globalGithubTree, "", filter, 0);
            } else {
                // Affichage racine seulement, dossiers repliables
                treeDiv.innerHTML = renderTreeCollapsible(globalGithubTree, "", 0, "root");
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // R√©cup√©rer le chemin demand√© qui a conduit √† la page 404
            const requestedPath = window.location.pathname.split('/').pop() || '';
            document.getElementById('current-path').textContent = 'Chemin recherch√©: ' + requestedPath;
            
            // Pr√©-remplir le champ de recherche avec le chemin demand√©
            document.getElementById('search-term').value = requestedPath;
            
            // Ex√©cuter automatiquement la recherche
            if (requestedPath) {
                performSearch();
            }

            // Afficher la liste des fichiers GitHub (par d√©faut : tout)
            displayGithubFilesTree();

            // Bouton "Afficher tous les fichiers du d√©p√¥t"
            document.getElementById('show-all-files').addEventListener('click', function() {
                document.getElementById('search-term').value = "";
                displayGithubFilesTree();
            });

            // Recherche dans l'arborescence des fichiers
            document.getElementById('search-term').addEventListener('input', function() {
                const val = this.value.trim();
                if (val) {
                    displayGithubFilesTree(val);
                } else {
                    displayGithubFilesTree();
                }
            });
        });
    </script>
    <script>
 // Configuration s√©curis√©e
 const ENCRYPTION_KEY = "TroupeSaintElme2025";
    const encryptedData = {
      githubToken: "U2FsdGVkX18bflIPTYoKWYCFcJFneYp3xcwtgiHr90CLkbqlQOcfanBT7V1580l1RR5QFvZHXPxpHghmzzwUPc8pw7VN1W/Y+pOTRO0J4OfZx23zkkqmayC7/2EqfRvthq+OkDLXg1v7QsSqLjgzqQ==",
      githubOwner: "U2FsdGVkX186j9ffhpnA1a9MJtRiIa/04ShDXl5sbNQ=",
      githubRepo: "U2FsdGVkX19Zfsoi64wXtZeYZ3LTFaved+N7Qx6X6sdPw7IlmTc4/tOAKOkGPcHv",
      githubBranch: "U2FsdGVkX18dk0LRwjtJUNSytvcU62mMHrQE7rv8WUQ="
    };

    function decrypt(encryptedText) {
      try {
        const decrypted = CryptoJS.AES.decrypt(encryptedText, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8);
        return decrypted;
      } catch (error) {
        console.error("Erreur de d√©chiffrement:", error);
        return null;
      }
    }

    function getSecureValue(key) {
      if (!encryptedData[key]) {
        console.error(`La cl√© ${key} n'existe pas dans les donn√©es s√©curis√©es`);
        return null;
      }
      return decrypt(encryptedData[key]);
    }

    // Utiliser les valeurs d√©chiffr√©es
    const token = getSecureValue('githubToken');
    const owner = getSecureValue('githubOwner');
    const repo = `${owner}/${getSecureValue('githubRepo')}`;
    const branch = getSecureValue('githubBranch');

    </script>
</body>
</html>
